# Aurora.md

# はじめに
- RDBMSをもう一度考えて作った
- MySQLのエコシステムをそのまま活用
- 多くのサードパーティ監視ツールとかも、そのまま使える。
- インスタンスタイプは5つ。

# アーキテクチャについて語る
- SQL、Transactions、Cachingのレイヤー。Logging+Storageのレイヤー、S3でバックアップの3つのレイヤーにわけている。

## キャッシュレイヤの分離
- キャッシュをデータベースプロセス外に移動
- DBプロセスのリスタートが発生してもキャッシュが残った状態を維持できる
- 高速リカバリが可能

## セキュリティ
- データの暗号化
- SSLを利用したデータ通信の保護
- ノードへの直接アクセスは不可能

## Auroraのストレージ
- Aurora用に用意したストレージ
- SSDを利用したシームレスにスケールするストレージ
- 64TBまで自動でシームレスにスケールアップ
    - パフォーマンスや可用性に影響なし
- 6つのディスクを4つのAZに配置
- 2つのコピーに障害が起こっても、読み書きに影響はない
- 3つのコピーに障害が発生しても読み込みは可能
- 自動検知、修復
- 4本に書き込み完了で正常書き込み完了とする。最終的に6本に書き込む。
    - 差分をストレージノードに書き込む。ひたすら末尾に書き込む。
    - 常に裏ではGCが発生しているが、影響は出ていない。

## レプリケーション
- マスターでコミットがおわってから、10-20msecでレプリケートされる。

## コスト比較：Aurora vs RDS for MySQL
- 性能面以外でもコストメリットがある。30%ぐらい？

## フェイルオーバとリカバリ
- MariaDBのJDBCドライバを使うと数十秒で復旧できる。
- リードレプリカが存在しない場合は15分ほど
- 存在する場合は1分ほど

## クラスタエンドポイント
- 常にWriterをさすポイント
- 読み込みはInstanceEndpoint
- レプリカラグをコンソールで見れる
- cnameで指示しているだけ。DNSをベースにFOする。TTL注意。
- RDS MySQLより高速にフェイルオーバする。
- キャッシュの整合性を取るため、各ReaderのAuroraプロセスリスタートする。アプリ側でリトライの作りこみをした方がいい。

## なぜFOがはやいのか。
- クラッシュリカバリがストレージレイヤで行われる。
- 2-30秒でもどる。検知の時間は一緒だが、リカバリが短い。

## Streaming snapshotとPITR
- ストリーミングバックアップですぐにS3に書き込まれている。
- PITRのタイミングによって、1-2分前まで戻せる。

## データ修復
- 10GBで一個のセグメントとしている。セグメントごとにリカバリが走る。
- シングルではなく、並列でS3から戻していくから、はやい。

## FOのテストができる
- クラッシュシュミレートのSQL（ALTER SYSTEM CRASH）
- レプリケーション障害をシュミレート
- 他にもディスク障害、ディスクコンジェクションをシュミレート

## 性能テスト（MySQL5.7、5.6、Aurora）
- AMIの提供もしているので、再現環境を作れる。
- AuroraはManyMoreを意識して作られているので、CPUが増えれば増えるほど性能を上げていける。
- ベンチマークより、実環境の方が早くなるだろう。
- HA構成に力を入れているため、裏の検証を十分に実施している。

## チューニング指針
- 効率的な作りにしているため、CPU、メモリの利用率は高めに出る。性能悪化しないのであれば、気にしない。
- クエリレイテンシ、スループット、cache hitレートに注目すること。
- まずはデフォルトパラメータグループを使用
- 適切なインスタンスタイプを選択することが大切
- 性能向上のために行っていること
     - DiskIOのトラフィックをへらす
     - ログのレコードだけを飛ばす。通常MySQLだとブロックごとに飛ばす。
     - 6本のディスクに飛ばしているにも拘らず、1/8の量になっている。
 - スレッドプール
     - Adaptive Thread Pool
     - 一個のスレッドで複数のコネクションを受け持つ。
     - スレッドの数が接続数に合わせて増えていく。
     - スレッドの数を最適にして、その分をSQLの処理に回す。

## もろもろ特徴
- 非同期グループコミット
    - まとめてディスクにプッシュダウンしていく。
- 過去数か月で改善したこと
    - ロック競合
    - バッチ操作
    - 顧客フィードバック
- 移行に向いているもの
    - クエリ同時実行数やテーブルサイズが大きいもの
    - 複数のサーバにシャーディングしているもの
- クロスリージョンレプリケーション対応
    - DRや他のリージョンへDBを移設するなど
    - 最新のAuroraでbinlog_formatの設定が必要
    - 若干の性能劣化がある
    - 距離によってレイテンスが違ってくる
- アカウント間でスナップショットを共有可能
    - スナップショットをパブリックで共有することも可能
    - 暗号化されていないスナップショットから暗号化クラスタを作成可能
- ローカルタイムゾーン対応
- フェイルオーバ順の指定
- 拡張モニタリングでOSのメトリクス（57種類を1-60秒）がみれる
    - Cloudwatchlogs→Lambda→ElasticSearchでみたり。
- 格納時暗号化。データの中身の暗号化。
- パフォーマンス改善
    - Largeデータセットに対するリード改善
    - FastInsert
    - Parallel Read Ahead→B-Treeスキャンを向上させる。シーケンシャルアクセスのパフォーマンスを大幅改善。現在はWriteerのみ有効、今後Readerも。
- Lab mode
    - 今後提供予定の機能を試すことが可能
    - aurora_lab_mode変数で設定可能

## まとめ
- クラウド時代にAmazonが再設計したRDBMS
- 高いクエリ実行並列度・データサイズが大きい環境で性能を発揮
- 高可用性・高速なフェイルオーバ・実環境での性能向上を実現するための多くのチャレンジ

## Q&A
- 小さいタイプの提供はないのか？
    - r3シリーズ向けにチューニングしているため、現在は伝えられるものがない。
- キャッシュを明示してクリアできるのか？
    - 提供していない。インスタンスを再起動するしかない。
- ストレージにcpuクレジットの概念はあるのか？
    - ないです。入っているデータでパフォーマンスが決まる。
    - ホットキーでは性能出しにくいが、分散していると最大限発揮できる。
- ローカルだとMySQL5.6を使うことをおすすめ。
- IOPSの制約を受けるのはひとつひとつのインスタンス単位。
- MySQL互換。現在、5.6。今後のバージョンにどう追従していくのか？
    - 目安はない。
- スローログをインスタンスストアに保存している関係で各インスタンスのサイズに引っ張られる。改善予定。気にした方がいい。


次回は8/3 VPC